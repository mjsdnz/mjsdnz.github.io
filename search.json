[{"title":"拉格朗日插值证明+模板","date":"2023-08-28T11:46:08.915Z","url":"/2023/08/28/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E8%AF%81%E6%98%8E-%E6%A8%A1%E6%9D%BF/","categories":[["数学","/categories/%E6%95%B0%E5%AD%A6/"]],"content":" 开学力，悲（虽然一直没放假吧）。在做往年 真题的时候出现了这么一道题，于是开始恶补拉格朗日插值（之前学的都还给高数课本了）。 拉格朗日插值首先让我们一起膜拜一下约瑟夫·拉格朗日。 定义概念一般地，若已知 在互不相同 个点 处的函数值 （即该函数过 这 个点），则可以考虑构造一个过这 个点的、次数不超过 的多项式 ,使其满足： P_n(x_k)=y_k \\ \\ \\ k=0,1,\\dots,n要估计任一点 ，，则可以用 的值作为准确值 的近似值，此方法叫做“插值法”。称上述式为插值条件（准则），含 的最小区间 ，其中 。 定理满足插值条件的、次数不超过 的多项式是存在而且是唯一的。 证明我们先回顾一下当 的情况，也就是小升初就学过的“待定系数法”。 给定两个点 和 ，求出函数 的表达式。 这个大家都会，我就不赘述了，下面我们换一个问法，求出函数 的值 （ 为给定实数）。下面我们用给定的两个点表示一下该值。 f(x_k)=y_k=\\frac{y_{k+1}-y_{k}}{x_{k+1}-x_k}x_k\\\\ 0=y_k-\\frac{y_{k+1}-y_{k}}{x_{k+1}-x_k}x_k\\\\ f(x)=\\frac{y_{k+1}-y_{k}}{x_{k+1}-x_k}x+0\\\\ f(x)=y_k+\\frac{y_{k+1}-y_{k}}{x_{k+1}-x_k}(x-x_k)=y_k\\frac{x-x_{k+1}}{x_k-x_{k+1}}+y_{k+1}\\frac{x-x_k}{x_{k+1}-x_k}接下来我们引入一个叫做线性插值基函数的东西，其表示为 ，意义为 。 因此 f(x)=l_k(x)y_k+l_{k+1}(x)y_{k+1}\\\\ l_k(x)=\\frac{x-x_{k+1}}{x_k-x_{k+1}}\\\\ l_{k+1}(x)=\\frac{x-x_k}{x_{k+1}-x_k}接着，我们来考虑考虑 的情况。 f(x_{k-1})=y_{k-1}\\\\ f(x_k)=y_k\\\\ f(x_{k+1})=y_{k+1}\\\\ f(x)=y_{k-1}l_{k-1}(x)+y_kl_k(x)+y_{k+1}l_{k+1}(x)易得 l_{k-1}(x)=\\frac{(x-x_k)(x-x_{k+1})}{(x_{k-1}-x_k)(x_{k-1}-x_{k+1})}\\\\ l_k(x)=\\frac{(x-x_{k-1})(x-x_{k+1})}{(x_k-x_{k-1})(x_k-x_{k+1})}\\\\ l_{k+1}(x)=\\frac{(x-x_{k-1})(x-x_k)}{(x_{k+1}-x_{k-1})(x_{k+1}-x_k)}接下来我们考虑一般情况。 已知函数 在 个插值节点 上的函数值为 ，求构造一个次数不超过 的插值函数多项式 ，使得 成立。 P_n(x)=l_0(x)y_0+l_1(x)y_1+\\dots+l_n(x)y_n\\\\ l_i(x_j)= \\begin{cases} 1, \\ \\ x_j=x_i \\\\ 0, \\ \\ x_j\\not=x_i \\end{cases}由此可得 l_i(x)=\\frac{(x-x_0)(x-x_1)\\dots (x-x_{i-1})(x-x_{i+1})\\dots (x-x_n)}{(x_i-x_0)(x_i-x_1)\\dots (x_i-x_{i-1})(x_i-x_{i+1})\\dots(x_i-x_n)}\\\\ P_n(x)=\\sum_{i=0}^ny_il_i(x)=\\sum_{i=0}^n(\\prod_{j=0,j\\not=i}^n\\frac{x-x_j}{x_i-x_j})y_i至此我们就获得了拉格朗日插值公式 P_n(x)=\\sum_{i=0}^n(\\prod_{j=0,j\\not=i}^n\\frac{x-x_j}{x_i-x_j})y_i模板根据公式，我们可以直接写出 算法： P4781 【模板】拉格朗日插值 Code(mod=998244353) "},{"title":"图论总结","date":"2023-08-22T10:09:01.363Z","url":"/2023/08/22/%E5%9B%BE%E8%AE%BA%E6%80%BB%E7%BB%93/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"]],"content":"图论总结图的基本表示方法设 为一张图， 为点集， 为边集，则有 G=(V,E)\\\\ V={v_1,v_2,\\dots,v_n}\\\\ E=\\{e_{i,j}\\}_{i,j=1}^n对于每一条边 都有其对应权值 。 图的存储方法 首先我们可以根据表示方法来写出一种非常直接的存图方法 Code 我们可以发现在代码中的 变量以一个二维矩阵的形式存在，因此也将其称为邻接矩阵。此类存图方法通常用于存储点数较少的图。 我们可以借鉴链表的存储方法，将图用链表存储起来，被称为链式前向星。 Code 当然我们也可以以点为中心，将该点可以扩展出来的边存在该点中，称为邻接表。 Code 图论基础算法最短路 SPFA一种老少皆宜的最短路算法，由于他简单易懂的代码和十分容易被卡的特性，深受OIer和出题人的喜爱。 Code 闲的没事版class封装逆天代码 Dijkstra相较于SPFA来说，Dijkstra有更加稳定的复杂度，虽然在随机数据上比SPFA多一个 ，但至少不那么容易被卡。 Code 拓扑排序某些事件需要其他事件完成后在进行，因此为了解决事件处理的先后问题而引入了拓扑排序，我们可以将当前任务的所有前置任务连向当前任务，然后进行BFS搜索，只有当某一个点的入度为 时才将其插入队列。 例题 P3243 [HNOI2015] 菜肴制作 Code 最小生成树最小生成树即在给定图中保留部分边使图转换成一棵树，并且使得所有边权最小。 Kruskal Code Prim Code 最近公祖先一个经典树上问题，就是找两个节点在树上的最近公祖先。 倍增法 Code（直接贺了一篇写的很详细的题解） 树剖法 Code 缩点一些有关连通性的基本概念 连通分量在一张图中的某一连通子图被称为该图的连通分量。 无向图的连通性 割点即删除此点后会使当前连通分量分为两个或多个。 割边即删除此边后会使当前连通分量分为两个或多个。 双连通 点双连通在一连通图中任选两点，若它们之间存在至少两条点不重复的路径，则称为点双连通，也就是说在点双联通中没有割点。 边双联通在一连通图中任选两点，若它们之间存在至少两条边不重复的路径，则称为边双连通，也就是说在边双联通中没有割边。 有向图的连通性 强联通在有向图中，若有两点 和 可以互相到达，即 可以到达 ， 也可以到达 ，则称 与 是强联通的，若此图中任意两点都可以互相到达，则称此图为强连通图。 经典算法 Tarjan Code Kosaraju一个不太常用的算法，可以自行了解。 欧拉路直接贺的OI-WIKI。 定义 欧拉回路：通过图中每条边恰好一次的回路 欧拉通路：通过图中每条边恰好一次的通路 欧拉图：具有欧拉回路的图 半欧拉图：具有欧拉通路但不具有欧拉回路的图 性质欧拉图中所有顶点的度数都是偶数。 若 是欧拉图，则它为若干个环的并，且每条边被包含在奇数个环内。 判别法 无向图是欧拉图当且仅当： 非零度顶点是连通的 顶点的度数都是偶数 无向图是半欧拉图当且仅当： 非零度顶点是连通的 恰有 个奇度顶点 有向图是欧拉图当且仅当： 非零度顶点是强连通的 每个顶点的入度和出度相等 有向图是半欧拉图当且仅当： 非零度顶点是弱连通的 至多一个顶点的出度与入度之差为 至多一个顶点的入度与出度之差为 其他顶点的入度和出度相等 无向图欧拉路求解算法 例题 P2731 [USACO3.3] 骑马修栅栏 Riding the Fences Code 基环树基本概念基环树就是有一个环的树，若将该环断开任意一条边，则会形成一棵树，若全部断开则会形成森林。 内向树就是每个点有且仅有一条出边 外向树就是每个点有且仅有一条入边 解题思路绝大部分基环树的题基本都是用拆环来解决的，可以说处理好环就处理好了基环树。 例题 P4381 [IOI2008] Island Code 例题 P3533 [POI2012] RAN-Rendezvous Code 网络流因为不是 考点所以只提一嘴。 安利一下自己的文章网络流 解题思路主要就是找到约束条件，在约束条件的基础上建图。 例题 P3973 [TJOI2015] 线性代数 Code 建图思想同余最短路 问题特征 给 个可以重复利用的整数，要求求出这 个数能拼凑出来多少其他整数。 给 个整数，求出这 个整数不能拼凑出来的最小/最大整数。 至少要拼几次才能拼出模 余 的数。 解题思路我们可以把“拼数”的操作抽象成一个图，我们可以发现 的结构很像最短路中的 ，因此我们可以以此来建图。 例题 P3403 跳楼机 Code 分层图分层图主要用在一些改动图或者受到时间限制的问题中，比较好想。 例题 Grass Cownoisseur G Code 差分约束 问题特征 给定 个变量 以及 个约束条件，每个约束条件是由两个其中的变量做差构成的，形如 。求出一组解 ，使得所有的约束条件得到满足，否则判断出无解。 那么很明显这是一个简单的线性规划问题，那么首先我们建立一下单纯型模型（误）。 想看线性规划解法的可以去看我的线性规划入门博客 解题思路我们先从一个不等式入手 x_i-x_j\\le c_k再看看最短路的三角不等式是什么 dis_v \\le dis_u+val_k这两个不等式很明显可以互相转化，如下。 x_i\\le x_j+c_k这其实就是差分约束的本质。 例题 P1993 小 K 的农场 Code 2-SAT 问题特征 给定 个集合 ，表示 与 有某种关系（不能同时选/必须同时选/任意选/其中一个必选）。然后从每个集合选择一个元素，判断能否选 个两两不矛盾的元素。 我们可以令一条有向边 的意义为选了 元素就必须选 元素，用 表示 的反面，下面考虑4中情况： 不能同时选：选 就必须选 ，选 就必须选 ，即 。 必须同时选：选 就必须选 ，选 就必须选 ，即 。 任意选（至少一个）：选 就必须选 ，选 就必须选 ，选 就必须选 ，选 就必须选 ，即 。 必选：直接 ，必然选 。 接下来我们只需要判断 与 是否在一个强连通分量上即可，我们可以使用Tarjan算法。 例题 P4782 【模板】2-SAT 问题 Code 数据结构优化建图如果某道题要求区间建边，那么大概率就是数据结构优化建图了。 例题： Legacy [ARC069F] Flags P3588 [POI2015] PUS P5025 [SNOI2017] 炸弹 前缀优化建图 问题特征 从 向区间 以外的点连长度为 的边。 从区间 以外的点向 连长度为 的边。 从区间 以外的点向 以外的点连长度为 的边。 这种问题也可以用线段树优化解决，但是线段树比较繁琐，根据问题特征，我们其实可以用一种更加简洁的方式————前缀和，来解决这类问题。 我们可以我们可以设置前缀数组 ，令其连向 与 ；设置后缀数组 ，令其连向 与 。 对于操作 ，我们只需要把 连向 和 即可。其余两个操作同理。 例题： P6378 [PA2010] Riddle Radio Stations P3783 [SDOI2017] 天才黑客 参考资料 panyf-常见优化建图技巧 OI-Wiki 图论部分 "},{"title":"浅谈关系矩阵","date":"2023-08-19T13:26:40.806Z","url":"/2023/08/19/%E6%B5%85%E8%B0%88%E5%85%B3%E7%B3%BB%E7%9F%A9%E9%98%B5/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"]],"content":" 原地址 浅谈关系矩阵什么是关系矩阵 举个例子： \\begin{vmatrix} 1& 0& 1\\\\ 0& 0& 1\\\\ 1& 0& 0 \\end{vmatrix} 这个关系矩阵就表示了3个抽象物体的关系： \\begin{vmatrix} 1->1有& 1->2没& 1->3有\\\\ 2->1没& 2->2没& 2->3有\\\\ 3->1有& 3->2没& 3->3没\\\\ \\end{vmatrix} 注意：关系是有向的，也就是说1-&gt;2有关系不一定2-&gt;1也有关系。 关系矩阵和图论中的邻接矩阵本质上是一样的，所以我们也可以用图论的方式来理解关系矩阵。 关系矩阵的表示对于元素集合 ,关系。 用关系矩阵表示为 关系矩阵的性质自身性质 自反性 关系矩阵主对角线上所有元素的值都为1。在图论中则表示每个点都存在自环。 反自反性 关系矩阵主对角线上所有元素的值都为0。在图论中则表示每个点都不存在自环。 对称性 对于 ，关系矩阵D中的元素 与 相等。在图论中则表示为每一条边都为双向边或自环。 反对称性 对于 ，关系矩阵D中的元素 与 不相等或全为0。在图论中则表示为任意两点之间仅有一条单向边或无边，允许存在自环。 非对称性 对于 ，关系矩阵D中的元素 与 不相等或全为0，且 等于0。在图论中则表示为任意两点之间仅有一条单向边或无边，无自环。 运算性质 逆运算相关性质 关系的逆的关系矩阵等于关系矩阵的逆 合成运算相关性质 其中 是矩阵的逻辑乘法，运算法则与矩阵乘法类似，逻辑乘法使用 运算，逻辑加法使用 运算 食用方法及技巧图论逻辑矩阵在图论中的应用十分广泛，例如邻接矩阵就是一种逻辑矩阵的拓展，由于应用的实在是太广了，所以就先鸽了这部分。 反演反演本身就是求两个函数之间的关系，很适合用关系矩阵来推导。 小试牛刀我们最常见到的反演关系就是前缀和与差分了，设 为前缀和， 为差分，则有： \\begin{align*} F_n&=\\sum_{i=0}^{n}G_i\\\\ G_n&=F_n-F_{n-1} \\end{align*}我们设 为关系矩阵，用于描述求和关系： \\begin{align*} F_{n}&=\\sum_{i=0}^{n}G_i\\\\ &=\\sum_{i=0}^{\\infty}A_{n,i}G_i\\\\ \\\\ F&=G\\times A\\\\ G&=A^T\\times F \\end{align*}设 为差分关系矩阵： \\begin{align*} G_n&=\\sum_{i=0}^{\\infty}B_{n,i}F_i\\\\ &=F_n-F_{n-1}\\\\ G&=F\\times B\\\\ F&=B^T\\times G \\end{align*} 上面写的可能有些冗长，目的是为了帮助像我一样的蒟蒻理解，大佬误喷。 那么有 \\begin{align*} A_{n,i}&=i\\le n\\\\ B_{n,i}&= \\begin{cases} & -1 \\ \\ &(i=n-1)\\\\ & 1 &(i=n) \\end{cases} \\\\ \\\\ (A\\times B)_{n,m}&=\\sum_{i=0}^{\\infty}A_{n,i}B_{i,m}\\\\ &=\\sum_{i=n}^{\\infty}([m=i]-[m=i-1])\\\\ &=[n=m]\\\\ &=I \\end{align*}所以 ，、矩阵互逆。 由此观之，两个互为反演的关系矩阵互逆。 因此，我们就可以用关系矩阵是否互逆来证明反演。 多维反演叠加若 \\begin{align*} \\begin{cases} F(n)=\\sum_{i=0}A_{1}[n,i]G(i)\\\\ G(n)=\\sum_{i=0}B_{1}[n,i]F(i) \\end{cases}\\\\ \\begin{cases} F(n)=\\sum_{i=0}A_{2}[n,i]G(i)\\\\ G(n)=\\sum_{i=0}B_{2}[n,i]F(i) \\end{cases} \\end{align*}则 \\begin{align*} \\begin{cases} F(n,m)=\\sum_{i=0}\\sum_{j=0}A_{1}[n,i]A_{2}[m,j]G(i,j)\\\\ G(n,m)=\\sum_{i=0}\\sum_{j=0}B_{1}[n,i]B_{2}[m,j]F(i,j) \\end{cases} \\end{align*}换而言之，反演系数等于每个维度反演系数之积。 证明： 设 \\begin{align*} A[(n_1,n_2)(i_1,i_2)]&=A_1[n_1,i_1]A_2[n_2,i_2]\\\\ B[(n_1,n_2)(i_1,i_2)]&=B_1[n_1,i_1]B_2[n_2,i_2] \\end{align*}则 \\begin{align*} &(A*B)[(n_1,n_2),(m_1,m_2)]\\\\ =&\\sum_{i_1=0}\\sum_{i_2=0}A_1[n_1,i_1]A_2[n_2,i_2]B_1[i_1,m_1]B_2[i_2,m_2]\\\\ =&\\sum_{i_1=0}\\sum_{i_2=0}A_1[n_1,i_1]B_1[i_1,m_1]A_2[n_2,i_2]B_2[i_2,m_2]\\\\ =&\\sum_{i_1=0}A_1[n_1,i_1]B_1[i_1,m_1]\\sum_{i_2=0}A_2[n_2,i_2]B_2[i_2,m_2]\\\\ =&[n_1=m_1][n_2=m_2]\\\\ =&[(n_1,n_2)=(m_1,m_2)] \\end{align*}"},{"title":"子集容斥与二项式反演学习笔记","date":"2023-08-19T13:24:03.865Z","url":"/2023/08/19/%E5%AD%90%E9%9B%86%E5%AE%B9%E6%96%A5%E4%B8%8E%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","categories":[["数学","/categories/%E6%95%B0%E5%AD%A6/"]],"content":" 原地址 子集容斥与二项式反演学习笔记子集容斥公式： \\begin{align*} g(S)&=\\sum\\limits_{T\\subseteq S}f(T)\\\\ f(S)&=\\sum\\limits_{T\\subseteq S}(-1)^{\\left|S\\right|-\\left|T\\right|}g(T) \\end{align*}证明： \\begin{align*} &\\sum\\limits_{T\\subseteq S}(-1)^{\\left|S\\right|-\\left|T\\right|}g(T)\\\\ =&\\sum\\limits_{T\\subseteq S}(-1)^{\\left|S\\right|-\\left|T\\right|}\\sum\\limits_{R\\subseteq T}f(R)\\\\ =&\\sum\\limits_{R\\subseteq T}f(R)\\sum\\limits_{R\\subseteq T\\subseteq S}(-1)^{\\left|S\\right|-\\left|T\\right|} \\end{align*}若 ，则 。 二项式反演公式： \\begin{align*} g_{i}&=\\sum_{k\\ge i}\\dbinom{k}{i}f_k\\\\ f_{i}&=\\sum_{k\\ge i}\\dbinom{k}{i}(-1)^{k-i}g_k \\end{align*}证明： \\begin{align*} &\\sum_{k\\ge i}\\dbinom{k}{i}(-1)^{k-i}g_k\\\\ =&\\sum_{k\\ge i}\\dbinom{k}{i}(-1)^{k-i}\\sum_{j\\ge k}\\dbinom{j}{k}f_j\\\\ =&\\sum_{j\\ge i}f_j\\sum_{i\\le k \\le j}\\dbinom{k}{i}\\dbinom{j}{k}(-1)^{k-i}\\\\ =&\\sum_{j\\ge i}f_j\\sum_{i \\le k \\le j}\\frac{k!}{i!(k-i)!}\\frac{j!}{k!(j-k)!}(-1)^{k-i}\\\\ =&\\sum_{j\\ge i}f_j\\frac{j!}{i!}\\sum_{i \\le k \\le j}\\frac{1}{(k-i)!(j-k)!}(-1)^{k-i}\\\\ =&\\sum_{j\\ge i}f_j\\frac{j!}{i!(j-i)!}(1-1)^{k-i}\\\\ =&f_j \\end{align*}同理： \\begin{align*} g_i&=\\sum_{k\\le i}\\dbinom{i}{k}f_k\\\\ f_i&=\\sum_{k\\le i}\\dbinom{i}{k}(-1)^{i-k}g_k \\end{align*}例题：黑暗前的幻想乡题目大意：给定一个无向图和每个公司能造的边，要求统计每个公司恰好建造一条边的生成树数量。 前置知识： [ ] 子集容斥 [ ] 矩阵树定理（生成树计数） 思路在没有公司限制的情况下，我们只需要跑一边生成树计数即可（挖个坑）。在加上限制条件之后，我们可以考虑将参加建造的公司看成一个子集 ，求出每个子集对应的生成树数量 ，最后子集容斥即可。"},{"title":"组合数学学习笔记","date":"2023-08-19T13:21:32.230Z","url":"/2023/08/19/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","categories":[["数学","/categories/%E6%95%B0%E5%AD%A6/"]],"content":" 原地址 组合数学学习笔记组合数学常用公式基本公式 排列： A_{n}^r=\\frac{n!}{(n-r)!} 组合： C_{n}^r=\\frac{n!}{r!(n-r)!} \\\\ \\dbinom{n}{r}=\\frac{n!}{r!(n-r)!} 二项式定理： n\\in \\mathbb{N},(x+y)^n=\\sum_{k=0}^{n}\\dbinom{n}{k}x^ky^{n-k} 广义二项式定理： 若 \\left | x \\right |"},{"title":"DP优化——斜率优化","date":"2023-08-19T13:08:56.106Z","url":"/2023/08/19/DP%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/","categories":[["动态规划","/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":" 原地址 前言听说 cnblogs 有些经济困难，所以先把那里的博文搬过来，当然还是祝愿 cnblogs 可以一直发展下去，听说 cnblogs 为了保命要出会员功能，如果确实合理的话也一定会大力支持的。 斜率优化学习笔记 前言 何为斜率优化？在日常生活中，我们食用的状态转移方程有时会以以下形式出现 y=kx+b什么？你说这不是状态转移方程，这是一次函数。的确，这是一次函数，但是我们可以将一些形态的转移方程转换成这样的形式，以 举例（原题：玩具装箱）。 设 a_{i}=s_{i}+i\\\\ b_{i}=s_{i}+i+L+1得 \\begin{split} F_{i}&=\\min(F_{j}+(a_{i}-b_{j})^2)\\\\ F_{i}&=\\min(F_{j}+a_{i}^2+b_{j}^2-2a_{i}b_{j}) \\end{split}我们先不考虑最小化的要求，单纯来看这个式子 F_{i}=F_{j}+a_{i}^2+b_{j}^2-2a_{i}b_{j}我们将有只有 的项看为 ；将只有 项看作；将 、 混合的项中的常数和 项看作 ， 项看作 。 设 y=F_{j}+b_{j}^2\\\\ k=2a_{i}\\\\ x=b_{j}\\\\ b=F_{i}-a_{i}^2欸，带入一下我们就能发现熟悉的东西 F_{i}-a_{i}^2=F_{j}+b_{j}^2-2a_{i}b_{j}\\\\ b=y-kx那有人就要说了，你这不是强加因果吗。咦，此言差矣，这个解释起来很简单，由于在枚举 ，所以只与 有关的变量我们当作定值（一会再说 的事），而只与 有关的我们就当作因变量，同理， 、 混合的项就是 。我们现在的目标是最小化 ，而且 是我们已知的，所以转化到一次函数上，我们要最小化的就是纵截距 。 在转换完问题后，我们看看这个一次函数有什么性质。很明显，这是条直线（废话），并且可以上下平移（改变纵截距大小），既然要最小化纵截距，那就要尽可能地使直线靠下，为了找到这样的合法情况，我们可以考虑维护一个包含所有合法状态的下凸包。 这是一个下凸包 可以将红线纵截距视为我们要维护的最小值。 很明显，红线必然在凸包上，关于凸包的维护可以自行学习计算几何相关内容，这里暂时跳过，只说一下大体思路。 对于这道题，由于斜率 单调递增，因此很容易用单调队列来维护凸包。在插入点之前，先判断队头的上一个节点与队头节点构成的直线斜率是否小于队头节点和要插入的节点构成的直线的斜率，由于下凸包的斜率是单调递增的，因此如果大于新插入的直线斜率的话说明上一个节点是一个上凸包，我们将队头推掉，反复进行这个过程知道不再大于，接着再将新节点插入。 咕~~~"},{"title":"高等数学","date":"2023-08-16T11:16:24.993Z","url":"/2023/08/16/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/","categories":[["数学","/categories/%E6%95%B0%E5%AD%A6/"]],"content":"一个令人喜闻乐见的专题前言：关于我为什么要讲高数： 在一个月不黑风不高的晚上，某位神犇在为我们讲一道名为十二重计数法(神犇的blog)的神仙数学题时，出现了一个十分有趣的式子: \\begin{equation*} \\begin{split} \\ln_{}{(1-x^{t})} & = \\int \\frac{-tx^{t-1}}{1-x^{t}}dx\\\\ & = \\int (-t \\sum_{i=1}x^{ti-1})dx\\\\ & = -\\sum_{i=1}\\frac{x^{ti}}{i} \\end{split} \\end{equation*}但是由于大家的修行不够，并没有悟到该式子的真谛，所以今天有我来填这个大坑。（有些公式的证明可能没有办法全部展示完，对于重要的公式会单独写几篇博客 挖坑小能手）。 导数引入我们先回想一个初中就学过的函数 。那么，对于这个朴实无华的二次函数，我们该如何求出函数上每个点的切线斜率呢？在考虑这个问题之前，让我们先想一想如何求一次函数斜率。对于一次函数 ，k就是该函数的斜率。当然，也可以表示为 k=\\frac{\\Delta y}{\\Delta x}或者 k=\\frac{y_{2}-y_{1}}{x_{2}-x_{1}} \\quad (y_{1} < y_{2} \\enspace , \\enspace x_{1} < x_{2})那我们是不是也可以用同样的方式表示二次函数在某一点上的斜率呢？我们用 表示一段区间上的斜率，其中 ， ，为了方便理解，我们直接上图。 可以表示为： \\begin{equation*} \\begin{split} \\Delta y & =f(x_{2})-f(x_{1}) \\\\ & = f(x_{1}+\\Delta x) - f(x_{1}) \\end{split} \\end{equation*} 那么 可以表示为： k=\\frac{f(x+\\Delta x) - f(x)}{\\Delta x} 下一步我们让无线趋近于0，符号表示为，这样就可以表示图像在点的斜率。 k=\\lim_{\\Delta x\\to 0}\\frac{f(x+\\Delta x) - f(x)}{\\Delta x} 斜率其实就是导数的几何意义，下面给出导数的定义。 导数的定义定义设函数 在点的某个邻域内有定义，当自变量在处有增量 ， 也在该邻域内时，相应地函数取得增量；如果与之比当时极限存在，则称函数在点处可导，并称这个极限为函数在点处的导数，记作①；②；③，即 f'(x_{0})=\\lim_{\\Delta x \\to 0}\\frac{\\Delta y}{\\Delta x}=\\lim_{\\Delta x \\to 0}\\frac{f(x_{0}+\\Delta x)-f(x_{0})}{\\Delta x} 导函数几何意义公式常用函数导数 导数运算法则 复合函数求导设 且和都可导（忘写如何判断函数是否可导了，挖个坑），则复合函数的导数为 {\\large{\\frac{dy}{dx}=\\frac{dy}{du} \\cdot \\frac{du}{dx}}} \\quad 或 \\quad {\\large{y'(x)=f'(x) \\cdot g'(x)}}高阶导数高阶导数就是对函数进行大于等于二次求导，例如二阶导数可以表示为或 f^{(n)}(x)=(f^{(n-1)}(x))' "},{"title":"网络流","date":"2023-08-16T11:16:24.991Z","url":"/2023/08/16/%E7%BD%91%E7%BB%9C%E6%B5%81/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"对网络流的初步认识写在前面这是本蒟蒻写的第一篇博客，请各位巨佬多多包涵，欢迎指出文章的错误。 什么是网络流？引入在最短路算法的学习中，我们将多个地点之间的道路转化成有向图（或无向图）来处理各个地点的最短路问题。网络流问题也类似，我们可以将生活中比较常见的物料流动系统，比如管道网络、信息网络、电网、物流网络等视为网络流。从生活中的例子里我们发现，网络流问题就是一类处理物料从源点以稳定速率生成，并通过有容量上限的各个物流通道，最后流向汇点的问题。下面给出网络流的具体定义。 定义网络流 G = ( V , E ) 是一个有向图，其中有N 个点、M 条边、源点S 、汇点T ，每条边 有一个非负的容量值 c ( u , v ) 0。 举个栗子：当然，除了表示容量值，我们还需要一个函数来定义当前流量，还有流之间的关系，接下来详细说一下流函数。流函数我们讲 定义为边的流量，并且满足一下性质： 1.容量限制：对于所有结点 u , v V ,要求 。 2.流量守恒：对于所有的节点 ，要求 。 3.斜对称：正向边的流量等于其对应反向边的流量经典问题——网络最大流既然已经明确了网络流的定义，那么不妨来看看这个最经典的网络流问题——网络最大流。通过上面的定义我们不难发现，在整个网络中存在多组流函数，其中使整个网络流量之和最大的流函数被称为最大流，此时的流量被称为最大流量。网络最大流问题既旨在寻找既定网络中的最大流量。为了处理最大流问题，我们伟大的先辈L.R.Ford和D.R.Fulkerson在1962年将原始-对偶算法应用于最大流问题，提出了Ford-Fulkerson方法（由于其方法有多种时间复杂度不同的算法实现，因此《算法导论》将其称为方法而不是算法，这里沿用此定义），下面引入相关概念。 Ford-Fulkerson方法简单来说，Ford-Fulkerson方法就是不断搜索可行的路径，并更新残余网络。 具体步骤： 1.一开始所有边的容量都为0。 2.根据网络流的三大性质，找到一条从s 到t的路径，并更新流量。 3.重复（2）操作，直到无法找到满足三大性质的路径。 那么，根据这三个步骤，我们的程序是不是已经呼之欲出了呢？ 诶，如果你只按这三个步骤搜索的话，或许已经发现这个程序会有一些错误，举个例子。很明显，我们已经没有办法找到其他符合要求的路径了，该网络流的最大流为1，但是我们得到的最大流并不是真正的答案，如果先走再走的话，该网络的最大流为2。究其原因，在的路径中边占据了之后的流量，我们可以认为这是一次 “错误” 的搜索，为了防止这种 “错误” 对以后产生影响，我们引入残留网络的概念。 残留网络：在每次搜索后，在经过的路径上反补一条与该路径方向相反的路径，形成的新图就叫残留网络。 这个过程可以理解为在每次搜索后建立一条用来 “反悔” 的路径，以保证之后的搜索不受 “错误” 查找的影响。Ford-Fulkerson方法就是基于残留网络和反补路径实现的。后文将详细讲述几个基于Ford-Fulkerson方法的算法 Edmonds-Karp算法EK算法是最典型的实现方式，按照Ford-Fulkerson的思路实现即可。为了防止在搜索时出现不断搜索一条路径的情况，我们用BFS实现。 Code 复杂度分析：EK查找增广路的总时间为 ,一次BFS时间为 ,所以总时间为 , Dinic算法在EK中，每次搜索都要重新找到一条由S到T的增广路，这样的复杂的显然是不可以接受的。在Dinic算法中，实现了一次对多条增广路的搜索。 Dinic思想： 1.BFS分层，记录每个节点最早被搜索到的深度。 2.DFS在分层图上搜索，每次只能搜索到下一个深度的邻居结点，找到一条从当前结点v到汇点T的路径，并在回溯时更新流量。 Code 趣味小知识 算法来源于苏联学者Yefim Dinitz1970年发表的论文，但是这篇文章由于收到刊物篇幅限制写的过于简短，晦涩难懂，后来被两位美国学者解释、实现并大力推荐，但是误把Dinitz拼成Dinic。Dinitz在2006年写了一篇文章来解释这个算法的来龙去脉。虽然Dinic算法看起来像是对EK算法的改进，但其实EK算法的出现要比Dinic算法晚两年（1972）。 ISAP算法ISAP算法是对Dinic算法的进一步改进，在Dinic中，我们进行了多次BFS分层，而ISAP只需要一次BFS分层，然后再分层图上多次寻找增广路，为了更新残留网络，ISAP直接在原分层图上修改，而不是像Dinic一样进行多次BFS，因此有更优秀的复杂度。 ISAP思想： 1.从汇点T开始BFS，记录每个节点到T的距离，可以理解为高度。 2.从源点S开始DFS，在寻找路径时，按从高到低的顺序递减搜索，在s的邻居节点中，从高度比s小的节点开始搜索，每次搜索高度减1，到达汇点T后回溯，更新残留网络。 3.回到s,若无法找到高度低于s的节点，则将s的高度提升到最低的邻居节点的高度加1的高度，若某一高度出现断层（即该高度没有节点），则说明没有新的增广路，退出搜索。 Code 挖坑 [x] 预留推进 [x] 费用流 [ ] 二分图匹配，最小割 完结散花由于本人是第一次写博客，如果有任何问题（排版，思路，代码等），欢迎留言。 作者邮箱：2759094765@qq.com "},{"title":"线性规划入门","date":"2023-08-16T11:16:24.989Z","url":"/2023/08/16/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/","categories":[["最优化","/categories/%E6%9C%80%E4%BC%98%E5%8C%96/"]],"content":"废话 小吐槽 这篇文章是续7月份省选无法拿到博客源码和八月初博客挂掉之后的第一篇博客，这之间的博文全部都放在了 里有时间会移植过来。 什么是线性规划？引入线性规划问题是最优化问题的一个分支，通常用于解决工厂的资源配置问题。对于每组变量有与其对应的限制条件，在满足所有条件的前提下最大或最小化目标函数。举个现实例子： 现在有甲、乙两种资源，和 、、、 四中由甲乙资源生产出来的产品，现有资源数、单位产品所需资源数以及单位产品可获得利润如下表所示。问如何组织生产能够使得利润最大？ 我们可以用数学公式来记录这几个变量之间的关系 设总利润为 ，产品 的生产量为 。 目标： \\max z=8x_1+20x_2+12x_3+15x_4约束条件： \\left\\{\\begin{matrix} x_1+10x_2+2x_3+3x_4\\le 18000\\\\ 3x_1+2x_2+5x_3+4x_4\\le 13000\\\\ x_1,x_2,x_3,x_4\\ge 0 \\end{matrix}\\right.通过这个例子，我们可以抽象出来线性规划的模型： \\max \\sum_{j=1}^nc_jx_j \\begin{array} \\\\s.t. \\left\\{\\begin{matrix} \\sum_{j=1}^na_{ij}x_j\\le b_i \\ \\ \\ (i=1,\\dots,m)\\\\ x_j\\ge 0 \\ \\ \\ (j=1,\\dots,n) \\end{matrix}\\right. \\end{array}其中 表示第 种产品的单位利润， 为第 种产品需要消耗第 种资源的消耗量， 为第 种资源的资源上限。 为了方便理解原问题和对偶问题的关系，这里先将刚才的例子转换为对偶问题再进行单纯形运算。 什么是对偶问题我们将刚才的例子转换一下，现在要求将甲、乙两种资源租给其他单位，使得本单位获利不低于其他单位生产出来的产品利润，要求最小化甲、乙资源总价值之和。 转化为线性规划模型： 目标： \\min w = 18000y_1+13000y+2\\\\约束条件： \\begin{cases} y_1+3y_2\\ge8\\\\ 10y_1+2y_2\\ge20\\\\ 2y_1+5y_2\\ge12\\\\ 3y_1+4y_2\\ge15\\\\ y_1,y_2\\ge0 \\end{cases}如果我们用矩阵的视角来观察原问题和对偶型问题的线性规划模型便可发现，对偶型问题实际上就是将原问题行列互换，并将约束条件取反。具体的变换规则可以参考这篇博客。 那么接着，我们终于可以开始学习如何求出最后的最优策略了。 什么是单纯形下面先介绍一些概念： 设 是约束方程组的 维系数矩阵，其秩为 ，是矩阵 中的一个 阶的满秩子矩阵，不失一般性，设 A=\\begin{pmatrix} &a_{11} \\ &\\dots \\ &a_{1m} \\ &a_{1m+1} \\ & \\dots \\ &a_{1n}\\\\ &\\vdots \\ &\\ddots \\ &\\vdots \\ &\\vdots \\ & \\ddots \\ &\\vdots\\\\ &a_{m1} \\ &\\dots \\ &a_{mm} \\ &a_{mm+1} \\ & \\dots \\ &a_{mn} \\end{pmatrix} X = \\begin{pmatrix} x_1 \\ \\dots \\ x_m \\ x_{m+1} \\ \\dots \\ x_{n} \\end{pmatrix}^T B=\\begin{pmatrix} &a_{11} \\ &\\dots \\ &a_{1m}\\\\ &\\vdots \\ &\\ddots \\ &\\vdots\\\\ &a_{m1} \\ &\\dots \\ &a_{mm} \\end{pmatrix}我们对线性规划问题的解进行一些分类： 可行解满足线性规划所有约束条件的一组解被称为可行解，可行解不一定满足最优策略。 最优解包含于可行解中，且满足最优策略。 "},{"title":"李超线段树学习笔记","date":"2023-08-16T11:16:24.988Z","url":"/2023/08/16/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","categories":[["数据结构","/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"李超线段树学习笔记引入李超线段树是一种解决解决二维平面直角坐标系中直线和线段的最值问题的数据结构，支持动态插入线段，查询某一横坐标上值最大(或最小)的直线标号或值的数据结构。 思想首先想想暴力，也就是枚举一遍所有线段，复杂度 。但是很明显这个复杂度是可以优化的，在维护一个无序序列的区间最值时，我们可以用线段树来实现，那么我们也可以将线段树搬到平面坐标系上，来维护区间的最大值线段。下面给出具体实现思想: 1.像线段树一样，把横坐标当做下标，每个节点维护这一区间上的最值，建树方法和线段树一样，只不过维护的是直线或线段。 2.当插入新线段时，若当前区域没有线段，则直接插入。下面考虑有旧线段的情况，设新线段为 ，旧线段为 。 若在左端点处 更优，那么 和 必然在左半区间中产生了交点， 只有在左区间才可能优于 ，递归到左儿子中进行下传； 若在右端点处 更优，那么 和 必然在右半区间中产生了交点， 只有在右区间才可能优于 ，递归到右儿子中进行下传； 若在左右端点处 都更优，那么 不可能成为答案，不需要继续下传。 Code "},{"title":"有源汇上下界最大流","date":"2023-08-16T11:16:24.986Z","url":"/2023/08/16/%E6%9C%89%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%A4%A7%E6%B5%81/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"前言终于来啦！ 拖了很长时间的博客（反正也没人看，我爱咋拖咋拖）。刚刚集训回来不知道干啥，更新一下博客，抽时间写个游记。 有源汇上下界最大流 转载+修正自己的文章，这个是原文 原题连接 基础 网络流（不会的可以搜索，或者看看本蒟蒻的 blog，这里略过） 上下界网络流相关问题（这个不会没有关系，我下面讲） 建模一到比较裸的有源汇上下界最小流。每条边必走一次，要求求出最小的流量。由于比较裸，这里当作上下界流的例题讲。 什么是有源汇上下界最小流顾名思义，就是在最大流的基础上增加了边的最小经过流量，使得整个网络可行，并且找出最小流量的方案。为了简化问题，我们先从无源汇上下界可行流说起。 求解无源汇可行流一个比较朴实的想法就是将一个边的最大限制减去最小限制，跑最大流即可。但是该方法并不满足流量守恒定律，因此做出一下调整。 我们在图中新建两个虚拟点，设置为新的虚拟源汇点 、。设 为点 所有入度边中的流量下限与所有出度中的流量下限之差。接下来我们对 与 的大小关系进行分类讨论。 若 则将该点与新源点 连接，流量为 。 若 则将该点与新汇点 连接，流量为 。 若 ，我们不需要考虑，反正不管怎么连流量都是 。 为什么要这么连呢，我们可以分析一下网络流的过程，由于我们直接连接的是流量上限 与 流量下限 的差作为该边的流量的，这会导致本来可以在 以内退流退掉的流量被清空了（可以回忆一下找增广路的退流过程）。我们对某一点 的所有 情况进行汇总，记录一个 来表示所有入度边中的流量下限与所有出度中的流量下限之差，可以理解为判断该点在总体上是流入还是流出，以此来弥补未能正确退流的流量。 注意：在原图中的原来的源汇点也需要与新源汇点进行连接。 有源汇上下界可行流有无源汇的最大区别就是源汇点是否满足流量守恒，我们在处理无源汇问题的时候不需要考虑源汇点的流量是否守恒，默认源点能无限产生，汇点能无限吸收。但在有源汇问题中考虑了源汇点的流量守恒性，不过处理起来也非常简单，我们只要让源汇点并入网络，也就是让汇点向源点连一条流量为无穷的边即可（注意这里的源汇点皆为旧源汇点）。 有源汇上下界最大流这个其实也很好处理，在跑完一边有源汇上下界可行流之后记录当前的最大流量（即汇点向源点的流量），判断一下当前网络流是否为满流，若不是，则无解，否这断开汇点向源点的边，跑一次无源汇上下界可行流，答案即为当前流加上之前记录的最大流。 有源汇上下界最小流和最大流类似，只不过是先处理无源汇上下界可行流，此时就已经将该网络中的所以增广路全部跑满，然后再连接汇点向源点的边，此时的最大流便是满足上下界要求的最小流。 源点和汇点已经加粗，一定要注意新旧源汇点的区别！ Code "},{"title":"最小费用最大流","date":"2023-08-16T11:16:24.985Z","url":"/2023/08/16/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"费用流问题前言依旧是填坑，讲解最小费用最大流的解决方法，对最大流不熟悉的同学可以看我的前几篇文章。 费用流问题一个网络流的扩展问题，从名字中就能看出，就是在容量限制的基础上加上经过每条边需要花费的费用。最小费用最大流问题就是为了解决在给的流量F时最小的花费，未指定F时则求流量最大时的最小花费。各位神犇可以思考一下该以何种顺序搜索。 思想不难看出，有以下两种搜索顺序： 1.先找最大流，然后再不断缩小花费 2.先找最短路（最小花费），再在路径上不断增加流量。 很明显第二种搜索顺序更容易理解，代码也容易实现。下面详细说明该思想的实现方法。 实现方法 首先，我们要找最短路。让我们回忆一下最短路算法都有哪些，你应该马上能想到Floyd、Bellman—Ford、SPFA和Dijkstra算法。这些都可以用吗？想想处理残留网络的过程，会在流经的边上建立一条反向边，那么反向边的花费一定与其正向边相反，因此我们要处理负权变，那么似乎Dijkstra就不能用了。因此我们选择Bellman—Ford或SPFA算法（Floyd复杂度太高）。找到最短路径之后我们记录一下路径，以便之后最大流处理。 其次就是处理最大流了。最大流算法上就没什么限制，Edmonds-Karp、Dinic、ISAP、HLPP都可以，用自己拿手的（复杂度小的）写就行。 SPFA+Dinic: Code SPFA+EK Code 题外话大家都知道，Dijkstra无法处理负权变，这样无法保证其贪心的正确性。不过，我们可以引入“势能”的概念，动态的维护每个边的边长，来保证Dijkstra的正确性。感兴趣的话可以去看《挑战程序设计》或者自行搜索。这里不做过多介绍了，只给出代码供大家参考。 Code(P2153[SDOI2009]晨跑代码) "},{"title":"网络流拓展——HLPP算法","date":"2023-08-16T11:16:24.983Z","url":"/2023/08/16/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%8B%93%E5%B1%95%E2%80%94%E2%80%94HLPP%E7%AE%97%E6%B3%95/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"更高效的网络流算法前言填坑，介绍一种更高效的网络最大流算法HPLL（预留推进） HPLL算法在上一篇文章中，我们介绍了三种最大流算法：Edmonds-Karp、Dinic和ISAP，其中最优的复杂度为(ISAP)。但这样还不够，ISAP仍有改进的空间，于是乎出现了HPLL算法，其复杂度为。 思路和ISAP类似，我们可以从汇点T开始BFS，查找到每一个结点的高度，然后每次搜索只更新到高度为当前节点减一的位置。这里HPLL引入了一个“溢出”节点的概念，可以理解为每个节点都有一个容量无限大的“水库”。当一个节点向下推流时，可以将流量先放在该节点的“水库”里。以便之后的搜索。 具体步骤： 1.BFS，记录每个节点的高度（和ISAP类似） 2.从源点S开始搜索，将“水库”中流量不为0的节点放入优先队列。 3.以从高到低的顺序更新队列里的每个节点，并将更新到的溢出节点放入优先队列。 4.若该节点无法再找到合法的路径（路径容量已满或者所有邻居节点都高于该节点）且该节点还有溢出流量，则将该点提升至邻居节点中高度最小的节点的高度加一处。 5.若发现某一高度出现断层，则说明其节点以上所有节点都无法再更新（具体证明可以看《算法导论》）。 不断重复3、4，直到所有节点都无法找到合法路径为止。 Code 后记本篇文章比较简短，主要填上一篇文章的坑，若有任何错误或不清楚的地方，欢迎留言。 作者邮箱：2759094765@qq.com "},{"title":"数据结构小结","date":"2023-08-16T11:16:24.981Z","url":"/2023/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B0%8F%E7%BB%93/","categories":[["数据结构","/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"数据结构小结 该文章主要用于存放数据结构思想和板子，具体做题思想以后补 挖坑:线段树专题、分块专题、平衡树专题 线段树1.什么是线段树?线段树本质就是一个二叉树，树上每个节点维护一段区间的值。 2.基本操作 建树(build) 就是从1号节点开始，每次劈两半，作为做儿子和右儿子，当发现当前结点的左右边界相等时，该节点的值即为建树序列的值。 查询(query) 递归查找，左边大于查找的左区间就查左儿子，右边同理。 修改(update) 如果修改区间覆盖当前区间，则直接给当前区间加上懒标记，否则递归查找加懒标记。 传递懒标记(push_down) 下传就完了。 3.代码: Code 树状数组1.什么是树状数组?树状数组主要是利用二进制的性质来维护的数据结构，虽然不如线段树全能，但是比线段树简短，只不过思想可能难以理解。 2.如何维护?每一个节点维护与其直连接点的和，具体可以看下面的图。 3.什么是lowbit?lowbit就是找到一个数二进制下最后一个1。 代码: 4.基本操作 单点修改(update) 从所选节点开始，增加自身及其父节点的值。 区间查询(query) 记录每个节点的前缀和，查询时用右范围的前缀和减去左范围。 5.代码: Code 平衡树1.什么是平衡树?平衡树的出现是由于在某些情况下，二叉树的复杂度会因为重心的偏移而退化成 ，为了防止这种情况的出现，我们强行将二叉树变为平衡树，来确保遍历的时间复杂度。 2.实现方法因为平衡树的实现方法实在是太多了，没有办法(懒得)给大家展示，因此这里只给出Splay和FHQ的代码。 3.代码: Splay FHQ 分块1.什么是分块?分块就是将一个大序列分成好几个小块，如果修改范围覆盖一个块就给块打上标记，否则暴力修改。大部分情况下将快长设为 ，当然为了应对有些玄学题的玄学复杂度也可以将块长设为 或者 。 2.基本操作 初始化 处理出块长，然后 将各个点放在块内(说白了维护个数组，标记某个下表所在的块)。 区间修改、赋值(update) 和思想一样，遇到大块打标记，遇到零碎点暴力修改，复杂度 。 单点查询(ask) 看所在的块中有没有标记，有则下传，没有则直接输出。 3.代码: Code 4.练习推荐在 loj 上有 9道分块的专题训练 虽然数据很水，但是全部拿分块做下来之后会极大提高对分块的熟练度，十分推荐去做。 完结挖坑[ ] 线段树题目讲解 [ ] 分块9题讲解 [ ] 平衡树题目讲解"},{"title":"挖坑表","date":"2023-08-16T11:16:24.980Z","url":"/2023/08/16/%E6%8C%96%E5%9D%91%E8%A1%A8/","categories":[["坑","/categories/%E5%9D%91/"]],"content":"天坑列表 [X] 有源汇上下界最大流 [x] noip往年题目部分思路(持续更新) [x] 数据结构小结 [ ] 高等数学 [ ] 线段树题目讲解 [ ] 分块9题讲解 [ ] 平衡树题目讲解 [ ] 线性规划入门 "},{"title":"P4177题解","date":"2023-08-16T11:16:24.978Z","url":"/2023/08/16/P4177%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["最大流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%A4%A7%E6%B5%81/"]],"content":"P4177 [CEOI2008] order 题解 原题链接 由于这道题题目太过简洁，所以就不放题目大意了。 建模一个最大权闭合子图的变种。此类问题可以抽象为以下几个对象的关系： 1.大项目，对应题中的工作。大项目中会包含许多个小项目，只有完成所有小项目才能完成大项目，并且完成大项目会获得相应的收益。 2.小项目，对应题中的工序。完成小项目需要一定的花费。 我们最终的任务就是选择需要完成的大项目，来使得收益减花费最大。 我们发现最小割可以完美解决这样的问题。只要将源点连向所有大项目，流量为大项目的收益，每个大项目向其所需的小项目连流量为无穷大的边，每个小项目向汇点连流量为小项目的花费的边。那么最小割割掉的割边流量就是保证合法性的最小流量。那么让所有大项目的收益减去最小割就是最大的收益。 不过这道题有一个“租”的操作，那我们就可以吧原本每个大项目向其所需的小项目连的边的流量由无穷大改为租金。原本设为无穷大的目的是为了在割边是不影响大小项目之间的连通性，毕竟这部分与统计答案无关。但是在多了个租金限制之后就需要统计小项目每次的花费了。因此将无穷大流量改为租金。 代码"},{"title":"P3872题解","date":"2023-08-16T11:16:24.977Z","url":"/2023/08/16/P3872%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["最大流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%A4%A7%E6%B5%81/"]],"content":"P3872 [TJOI2010] 电影迷 题解 原题链接 题目大意有 个物品，选第 个物品可以产生 的贡献（可正可负）。其中有些物品有配对，如果 物品和 物品配对，若只选择了其中的一个，则会产生 的贡献，求最大的贡献值。 建模很明显的最小割建模，在不考虑配对的情况下，从源点向贡献为正的物品连边，贡献为负的物品向汇点连边，流量为 。 下面考虑配对的情况，我们可以直接在 和 之间连一条流量为 的边，在跑最小割的时候，只有 和 不在同一边是该边才会产生贡献，符合我们的要求。 最后用所有物品的正贡献减去最小割即是答案。 代码"},{"title":"P3153题解","date":"2023-08-16T11:16:24.975Z","url":"/2023/08/16/P3153%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"P3153 [CQOI2009]跳舞 原题链接 题目大意给 个男孩和 个女孩，选出来 对跳一次舞，且两个人只能共同跳一次舞，要求跳舞次数最大。有的男孩女孩互相喜欢（一个人可能有很多喜欢的人），且不会有单相思，一个男孩只会和他不喜欢的女孩跳 次舞，女孩也同理。 建模首先考虑 的限制，通过直觉或者几次尝试我们发现可以用网络流问题中比较经典的拆点思想。 把一个人拆成两个点，一个向喜欢的人连边，一个向不喜欢的人连边，流量均为一。自己从向喜欢的人连边的点向向不喜欢的人连边的点连边，流量为 。（都为有向边） 如果没有需要 对来组成一首曲子的限制的话，我们可以直接设源点到每个男孩之间有一条流量为无限的边，女孩到汇点之间也有一条。不过由于场次的限制我们需要一些改变。 我们可以先把无限的流量改为一，然后跑多次最大流。如果流量是 则说明可以跳舞，增加一次答案后将源点向男孩，女孩向汇点的边全部重置一遍，然后接着跑最大流。 代码"},{"title":"P2934题解","date":"2023-08-16T11:16:24.973Z","url":"/2023/08/16/P2934%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"]],"content":"P2934 [USACO09JAN]Safe Travel G 原题链接 读题 1.不成熟的想法想必大家看完题之后都跟我一样有一个共同的想法，那就是跑次短路，但是稍微思考一下就会发现其实不然，下面举个反例：我们看从1到6的最短路，应该是 1 -&gt; 4 -&gt; 6 ,如果跑次短路的话则会找到1 -&gt; 2 -&gt; 4 -&gt; 6。诶，这不对吧，题目要求我们不经过1节点到i节点的最后一条边，也就是删去最短路上i节点的父边，但是这里并没有删，因此 次短路X。 2.真正的解题思路 这里介绍一种算法，最短路树。 最短路树顾名思义就是在确定最短路径后将此路构建为一棵树。这棵树的性质就是每个父节点到儿子节点的距离为最短路（废话）。当原图的一条边不在树上时，我们将其称为非树边。根据最短路树的性质，在断开i节点到它父亲的边后，最短路一定会经过至少一条非树边，而且仅经过一条非树边，因为如果该路径经过多条非树边，那么总有一条非树边可以用最短路树上的一条不包含被断开边的链替代。所以，断开i节点的父边后，其最短路径一定是树边 -&gt; 非树边 -&gt; 树边 的形式。下面直接贺别人的例子方便大家理解 接着，我们想想如何找到这条非树边。稍微想一下我们就能发现，只有边的两个节点的LCA的后代为i且i为两个节点其中一个节点的祖先时，这条边才有可能是最好路径。继续贺别人的例子 最后，节点i的答案长度。因为不变，所以当最小时，答案最小。所以我们将按照的大小来排序，再枚举这条边能更新的点，那么每个点第一次被更新时的即为所求，每次更新完答案，我们就将这个点删去，以加快搜索进度。复杂度:。 Code "},{"title":"P2172题解","date":"2023-08-16T11:16:24.971Z","url":"/2023/08/16/P2172%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"P2172 [国家集训队]部落战争 题解 原题链接 题目大意给一张地图，其中有能走的点和不能走的点，并且给你 和 ，表示行走路线（比如象棋中的马就是 ，）。每个能走的点只能走一次，且只能向下走。可以从任一点开始，任一点结束，求出走完所有能走的点的最少开始次数。 建模把题意化简完就会发现，这道题就是最小路径覆盖，这里简单说一下最短路径覆盖的思想： 既然要求最短路径覆盖，那么我们吧覆盖表示一下，覆盖=点总数-最大独立集，最大独立集其实就是最小割，因此覆盖=点总数-最小割，又因为最小割就是最大流，所以覆盖=点总数-最大流。 问题转换完了，模型也就出来了。利用拆点的思想，将一个点拆为入点和出点，以限制一个点的经过次数。源点连向所有入点，所有出点连向汇点，入点连向对应出点，流量都为一。对于可以联通的两点 和 ，将 的入点连向 的出点，流量为一。最后跑最大流即可。 注意： 由于只能往下走，所以不要在连边的时候连向上的边，一个点最多需要四次行走。 代码"},{"title":"P1674题解","date":"2023-08-16T11:16:24.970Z","url":"/2023/08/16/P1674%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"P1674 [USACO05FEB] Secret Milking Machine G 题解 原题连接 题目大意给出一张无向图，图上每条边只允许经过一次，给出经过图的次数 ，找到经过的最长边中长度最小的长度。 建模很明显费用流建模，每条边权值为长度，流量为一，直接连边，注意建双向边。那这个最长的边的长度怎么着呢？其实很简单，只要将更新 的条件由 改为 即可。同理，最小费用也改为 （ 为汇点）。当增广到的流量大于 时，直接跳出搜索，输出答案即可。代码用的是 Dijkstra 找增广路，本来还在想势能怎么更新，写着写着发现没必要用势能，就直接放个阉割版 Dijkstra 上去了，好像也不用开 longlong。 代码 第一次写题解，如有什么错误或者不理解的地方，欢迎留言。"},{"title":"P1264题解","date":"2023-08-16T11:16:24.968Z","url":"/2023/08/16/P1264%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"P1264 K-联赛 题解 原题连接 题目大意给你一个球队现在的胜利场次（失败场次屁用没有），以及没有进行的比赛 ，找出可能成为胜利次数最多的球队。 建模很明显，一个队跑一次最大流，当前队（现在跑网络流的队伍）能夺冠的条件就是其他队的胜利数都小于等于当前队的最大胜利数（废话）。 我们将当前队的最大胜利数表示为 ，第 i 队的胜利上限为 ，则 。 将每场比赛离散化一下，从源点向每个比赛连边，每个比赛向两个队连边，流量都为这两个队比赛的次数 。 每个队向汇点连边，流量为当前队（设当前队为 ）的最大胜利次数减去其他队的胜利数 。 最后只要判断最大流是不是当前队的最大胜利次数即可。 注意： 不要自己打自己。 不要连负流量的边。 不要忘记当前弧优化。 Code"},{"title":"noip往年题目部分思路","date":"2023-08-16T11:16:24.966Z","url":"/2023/08/16/noip%E5%BE%80%E5%B9%B4%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86%E6%80%9D%E8%B7%AF/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"]],"content":"2023春季测试T1涂色游戏 原题链接 把所有操作记录一个时间，最后输出时间最晚的那个颜色即可。 Code T2幂次 原题链接 暴力思路枚举底数暴力判断个数。 正解和暴力同理，加个当 时标记一下完全平方数的个数，最后统计的时候减去即可。 Code T3圣诞树 原题链接 可以发现一个性质，就是所选路线一定不相交（题目中的例子就是来忽悠人的）。这个性质可以让我们十分方便的进行区间dp，找到最高点后枚举左右区间，记录一个dp数组 dp[i][j][1/0] 表示最高点左边 个点和右边 个点，以及当前左边/右边最小路径和。 Code T4 密码锁+原题链接 笑死根本看不懂dp思路，直接写随机化，先随便选一列，然后随机打乱一下其他的列，然后完事了。 Code "}]