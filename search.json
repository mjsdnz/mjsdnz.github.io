[{"title":"网络流拓展——HLPP算法","date":"2023-05-09T10:54:42.678Z","url":"/2023/05/09/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%8B%93%E5%B1%95%E2%80%94%E2%80%94HLPP%E7%AE%97%E6%B3%95/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"]],"content":"更高效的网络流算法前言填坑，介绍一种更高效的网络最大流算法HPLL（预留推进） HPLL算法在上一篇文章中，我们介绍了三种最大流算法：Edmonds-Karp、Dinic和ISAP，其中最优的复杂度为(ISAP)。但这样还不够，ISAP仍有改进的空间，于是乎出现了HPLL算法，其复杂度为。 思路和ISAP类似，我们可以从汇点T开始BFS，查找到每一个结点的高度，然后每次搜索只更新到高度为当前节点减一的位置。这里HPLL引入了一个“溢出”节点的概念，可以理解为每个节点都有一个容量无限大的“水库”。当一个节点向下推流时，可以将流量先放在该节点的“水库”里。以便之后的搜索。 具体步骤： 1.BFS，记录每个节点的高度（和ISAP类似） 2.从源点S开始搜索，将“水库”中流量不为0的节点放入优先队列。 3.以从高到低的顺序更新队列里的每个节点，并将更新到的溢出节点放入优先队列。 4.若该节点无法再找到合法的路径（路径容量已满或者所有邻居节点都高于该节点）且该节点还有溢出流量，则将该点提升至邻居节点中高度最小的节点的高度加一处。 5.若发现某一高度出现断层，则说明其节点以上所有节点都无法再更新（具体证明可以看《算法导论》）。 不断重复3、4，直到所有节点都无法找到合法路径为止。 Code 后记本篇文章比较简短，主要填上一篇文章的坑，若有任何错误或不清楚的地方，欢迎留言。 作者邮箱：2759094765@qq.com "},{"title":"网络流","date":"2023-05-05T10:18:59.630Z","url":"/2023/05/05/%E7%BD%91%E7%BB%9C%E6%B5%81/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"]],"content":"对网络流的初步认识写在前面这是本蒟蒻写的第一篇博客，请各位巨佬多多包涵，欢迎指出文章的错误。 什么是网络流？引入在最短路算法的学习中，我们将多个地点之间的道路转化成有向图（或无向图）来处理各个地点的最短路问题。网络流问题也类似，我们可以将生活中比较常见的物料流动系统，比如管道网络、信息网络、电网、物流网络等视为网络流。从生活中的例子里我们发现，网络流问题就是一类处理物料从源点以稳定速率生成，并通过有容量上限的各个物流通道，最后流向汇点的问题。下面给出网络流的具体定义。 定义网络流 G = ( V , E ) 是一个有向图，其中有N 个点、M 条边、源点S 、汇点T ，每条边 有一个非负的容量值 c ( u , v ) 0。 举个栗子：当然，除了表示容量值，我们还需要一个函数来定义当前流量，还有流之间的关系，接下来详细说一下流函数。流函数我们讲 定义为边的流量，并且满足一下性质： 1.容量限制：对于所有结点 u , v V ,要求 。 2.流量守恒：对于所有的节点 ，要求 。 3.斜对称：正向边的流量等于其对应反向边的流量经典问题——网络最大流既然已经明确了网络流的定义，那么不妨来看看这个最经典的网络流问题——网络最大流。通过上面的定义我们不难发现，在整个网络中存在多组流函数，其中使整个网络流量之和最大的流函数被称为最大流，此时的流量被称为最大流量。网络最大流问题既旨在寻找既定网络中的最大流量。为了处理最大流问题，我们伟大的先辈L.R.Ford和D.R.Fulkerson在1962年将原始-对偶算法应用于最大流问题，提出了Ford-Fulkerson方法（由于其方法有多种时间复杂度不同的算法实现，因此《算法导论》将其称为方法而不是算法，这里沿用此定义），下面引入相关概念。 Ford-Fulkerson方法简单来说，Ford-Fulkerson方法就是不断搜索可行的路径，并更新残余网络。 具体步骤： 1.一开始所有边的容量都为0。 2.根据网络流的三大性质，找到一条从s 到t的路径，并更新流量。 3.重复（2）操作，直到无法找到满足三大性质的路径。 那么，根据这三个步骤，我们的程序是不是已经呼之欲出了呢？ 诶，如果你只按这三个步骤搜索的话，或许已经发现这个程序会有一些错误，举个例子。很明显，我们已经没有办法找到其他符合要求的路径了，该网络流的最大流为1，但是我们得到的最大流并不是真正的答案，如果先走再走的话，该网络的最大流为2。究其原因，在的路径中边占据了之后的流量，我们可以认为这是一次 “错误” 的搜索，为了防止这种 “错误” 对以后产生影响，我们引入残留网络的概念。 残留网络：在每次搜索后，在经过的路径上反补一条与该路径方向相反的路径，形成的新图就叫残留网络。 这个过程可以理解为在每次搜索后建立一条用来 “反悔” 的路径，以保证之后的搜索不受 “错误” 查找的影响。Ford-Fulkerson方法就是基于残留网络和反补路径实现的。后文将详细讲述几个基于Ford-Fulkerson方法的算法 Edmonds-Karp算法EK算法是最典型的实现方式，按照Ford-Fulkerson的思路实现即可。为了防止在搜索时出现不断搜索一条路径的情况，我们用BFS实现。 Code 复杂度分析：EK查找增广路的总时间为 ,一次BFS时间为 ,所以总时间为 , Dinic算法在EK中，每次搜索都要重新找到一条由S到T的增广路，这样的复杂的显然是不可以接受的。在Dinic算法中，实现了一次对多条增广路的搜索。 Dinic思想： 1.BFS分层，记录每个节点最早被搜索到的深度。 2.DFS在分层图上搜索，每次只能搜索到下一个深度的邻居结点，找到一条从当前结点v到汇点T的路径，并在回溯时更新流量。 Code 趣味小知识 算法来源于苏联学者Yefim Dinitz1970年发表的论文，但是这篇文章由于收到刊物篇幅限制写的过于简短，晦涩难懂，后来被两位美国学者解释、实现并大力推荐，但是误把Dinitz拼成Dinic。Dinitz在2006年写了一篇文章来解释这个算法的来龙去脉。虽然Dinic算法看起来像是对EK算法的改进，但其实EK算法的出现要比Dinic算法晚两年（1972）。 ISAP算法ISAP算法是对Dinic算法的进一步改进，在Dinic中，我们进行了多次BFS分层，而ISAP只需要一次BFS分层，然后再分层图上多次寻找增广路，为了更新残留网络，ISAP直接在原分层图上修改，而不是像Dinic一样进行多次BFS，因此有更优秀的复杂度。 ISAP思想： 1.从汇点T开始BFS，记录每个节点到T的距离，可以理解为高度。 2.从源点S开始DFS，在寻找路径时，按从高到低的顺序递减搜索，在s的邻居节点中，从高度比s小的节点开始搜索，每次搜索高度减1，到达汇点T后回溯，更新残留网络。 3.回到s,若无法找到高度低于s的节点，则将s的高度提升到最低的邻居节点的高度加1的高度，若某一高度出现断层（即该高度没有节点），则说明没有新的增广路，退出搜索。 Code 挖坑 [x] 预留推进 [ ] 费用流 [ ] 二分图匹配，最小割 完结散花由于本人是第一次写博客，如果有任何问题（排版，思路，代码等），欢迎留言。 作者邮箱：2759094765@qq.com "}]