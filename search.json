[{"title":"P4177题解","date":"2023-06-28T08:15:13.915Z","url":"/2023/06/28/P4177%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["最大流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%A4%A7%E6%B5%81/"]],"content":"P4177 [CEOI2008] order 题解 原题链接 由于这道题题目太过简洁，所以就不放题目大意了。 建模一个最大权闭合子图的变种。此类问题可以抽象为以下几个对象的关系： 1.大项目，对应题中的工作。大项目中会包含许多个小项目，只有完成所有小项目才能完成大项目，并且完成大项目会获得相应的收益。 2.小项目，对应题中的工序。完成小项目需要一定的花费。 我们最终的任务就是选择需要完成的大项目，来使得收益减花费最大。 我们发现最小割可以完美解决这样的问题。只要将源点连向所有大项目，流量为大项目的收益，每个大项目向其所需的小项目连流量为无穷大的边，每个小项目向汇点连流量为小项目的花费的边。那么最小割割掉的割边流量就是保证合法性的最小流量。那么让所有大项目的收益减去最小割就是最大的收益。 不过这道题有一个“租”的操作，那我们就可以吧原本每个大项目向其所需的小项目连的边的流量由无穷大改为租金。原本设为无穷大的目的是为了在割边是不影响大小项目之间的连通性，毕竟这部分与统计答案无关。但是在多了个租金限制之后就需要统计小项目每次的花费了。因此将无穷大流量改为租金。 代码"},{"title":"李超线段树学习笔记","date":"2023-06-28T01:15:58.050Z","url":"/2023/06/28/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","categories":[["undefined",""]],"content":"李超线段树学习笔记引入李超线段树是一种解决解决二维平面直角坐标系中直线和线段的最值问题的数据结构，支持动态插入线段，查询某一横坐标上值最大(或最小)的直线标号或值的数据结构。 思想首先想想暴力，也就是枚举一遍所有线段，复杂度 。但是很明显这个复杂度是可以优化的，在维护一个无序序列的区间最值时，我们可以用线段树来实现，那么我们也可以将线段树搬到平面坐标系上，来维护区间的最大值线段。下面给出具体实现思想: 1.像线段树一样，把横坐标当做下标，每个节点维护这一区间上的最值，建树方法和线段树一样，只不过维护的是直线或线段。 2.当插入新线段时，若当前区域没有线段，则直接插入。下面考虑有旧线段的情况。 (1) 原线段斜率小于新线段 若原线段在中点上的值小于 "},{"title":"P2172题解","date":"2023-06-25T08:58:29.578Z","url":"/2023/06/25/P2172%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"P2172 [国家集训队]部落战争 题解 原题链接 题目大意给一张地图，其中有能走的点和不能走的点，并且给你 和 ，表示行走路线（比如象棋中的马就是 ，）。每个能走的点只能走一次，且只能向下走。可以从任一点开始，任一点结束，求出走完所有能走的点的最少开始次数。 建模把题意化简完就会发现，这道题就是最小路径覆盖，这里简单说一下最短路径覆盖的思想： 既然要求最短路径覆盖，那么我们吧覆盖表示一下，覆盖=点总数-最大独立集，最大独立集其实就是最小割，因此覆盖=点总数-最小割，又因为最小割就是最大流，所以覆盖=点总数-最大流。 问题转换完了，模型也就出来了。利用拆点的思想，将一个点拆为入点和出点，以限制一个点的经过次数。源点连向所有入点，所有出点连向汇点，入点连向对应出点，流量都为一。对于可以联通的两点 和 ，将 的入点连向 的出点，流量为一。最后跑最大流即可。 注意： 由于只能往下走，所以不要在连边的时候连向上的边，一个点最多需要四次行走。 代码"},{"title":"P3153题解","date":"2023-06-21T07:04:14.163Z","url":"/2023/06/21/P3153%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"P3153 [CQOI2009]跳舞 原题链接 题目大意给 个男孩和 个女孩，选出来 对跳一次舞，且两个人只能共同跳一次舞，要求跳舞次数最大。有的男孩女孩互相喜欢（一个人可能有很多喜欢的人），且不会有单相思，一个男孩只会和他不喜欢的女孩跳 次舞，女孩也同理。 建模首先考虑 的限制，通过直觉或者几次尝试我们发现可以用网络流问题中比较经典的拆点思想。 把一个人拆成两个点，一个向喜欢的人连边，一个向不喜欢的人连边，流量均为一。自己从向喜欢的人连边的点向向不喜欢的人连边的点连边，流量为 。（都为有向边） 如果没有需要 对来组成一首曲子的限制的话，我们可以直接设源点到每个男孩之间有一条流量为无限的边，女孩到汇点之间也有一条。不过由于场次的限制我们需要一些改变。 我们可以先把无限的流量改为一，然后跑多次最大流。如果流量是 则说明可以跳舞，增加一次答案后将源点向男孩，女孩向汇点的边全部重置一遍，然后接着跑最大流。 代码"},{"title":"P1264题解","date":"2023-06-18T07:21:21.248Z","url":"/2023/06/18/P1264%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"P1264 K-联赛 题解 原题连接 题目大意给你一个球队现在的胜利场次（失败场次屁用没有），以及没有进行的比赛 ，找出可能成为胜利次数最多的球队。 建模很明显，一个队跑一次最大流，当前队（现在跑网络流的队伍）能夺冠的条件就是其他队的胜利数都小于等于当前队的最大胜利数（废话）。 我们将当前队的最大胜利数表示为 ，第 i 队的胜利上限为 ，则 。 将每场比赛离散化一下，从源点向每个比赛连边，每个比赛向两个队连边，流量都为这两个队比赛的次数 。 每个队向汇点连边，流量为当前队（设当前队为 ）的最大胜利次数减去其他队的胜利数 。 最后只要判断最大流是不是当前队的最大胜利次数即可。 注意： 不要自己打自己。 不要连负流量的边。 不要忘记当前弧优化。 Code"},{"title":"挖坑表","date":"2023-06-18T07:11:39.039Z","url":"/2023/06/18/%E6%8C%96%E5%9D%91%E8%A1%A8/","categories":[["坑","/categories/%E5%9D%91/"]],"content":"天坑列表 [ ] 有源汇上下界最大流 [ ] noip往年题目部分思路 [x] 数据结构小结 [ ] 高等数学 [ ] 线段树题目讲解 [ ] 分块9题讲解 [ ] 平衡树题目讲解 "},{"title":"noip往年题目部分思路","date":"2023-06-18T07:11:16.187Z","url":"/2023/06/18/noip%E5%BE%80%E5%B9%B4%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86%E6%80%9D%E8%B7%AF/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"]]},{"title":"数据结构小结","date":"2023-06-18T07:10:35.576Z","url":"/2023/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B0%8F%E7%BB%93/","categories":[["数据结构","/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"数据结构小结 该文章主要用于存放数据结构思想和板子，具体做题思想以后补 挖坑:线段树专题、分块专题、平衡树专题 线段树1.什么是线段树?线段树本质就是一个二叉树，树上每个节点维护一段区间的值。 2.基本操作 建树(build) 就是从1号节点开始，每次劈两半，作为做儿子和右儿子，当发现当前结点的左右边界相等时，该节点的值即为建树序列的值。 查询(query) 递归查找，左边大于查找的左区间就查左儿子，右边同理。 修改(update) 如果修改区间覆盖当前区间，则直接给当前区间加上懒标记，否则递归查找加懒标记。 传递懒标记(push_down) 下传就完了。 3.代码: Code 树状数组1.什么是树状数组?树状数组主要是利用二进制的性质来维护的数据结构，虽然不如线段树全能，但是比线段树简短，只不过思想可能难以理解。 2.如何维护?每一个节点维护与其直连接点的和，具体可以看下面的图。 3.什么是lowbit?lowbit就是找到一个数二进制下最后一个1。 代码: 4.基本操作 单点修改(update) 从所选节点开始，增加自身及其父节点的值。 区间查询(query) 记录每个节点的前缀和，查询时用右范围的前缀和减去左范围。 5.代码: Code 平衡树1.什么是平衡树?平衡树的出现是由于在某些情况下，二叉树的复杂度会因为重心的偏移而退化成 ，为了防止这种情况的出现，我们强行将二叉树变为平衡树，来确保遍历的时间复杂度。 2.实现方法因为平衡树的实现方法实在是太多了，没有办法(懒得)给大家展示，因此这里只给出Splay和FHQ的代码。 3.代码: Splay FHQ 分块1.什么是分块?分块就是将一个大序列分成好几个小块，如果修改范围覆盖一个块就给块打上标记，否则暴力修改。大部分情况下将快长设为 ，当然为了应对有些玄学题的玄学复杂度也可以将块长设为 或者 。 2.基本操作 初始化 处理出块长，然后 将各个点放在块内(说白了维护个数组，标记某个下表所在的块)。 区间修改、赋值(update) 和思想一样，遇到大块打标记，遇到零碎点暴力修改，复杂度 。 单点查询(ask) 看所在的块中有没有标记，有则下传，没有则直接输出。 3.代码: Code 4.练习推荐在 loj 上有 9道分块的专题训练 虽然数据很水，但是全部拿分块做下来之后会极大提高对分块的熟练度，十分推荐去做。 完结挖坑[ ] 线段树题目讲解 [ ] 分块9题讲解 [ ] 平衡树题目讲解"},{"title":"有源汇上下界最大流","date":"2023-06-18T07:10:18.907Z","url":"/2023/06/18/%E6%9C%89%E6%BA%90%E6%B1%87%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%A4%A7%E6%B5%81/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]]},{"title":"P1674题解","date":"2023-06-12T06:04:52.458Z","url":"/2023/06/12/P1674%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"P1674 [USACO05FEB] Secret Milking Machine G 题解 原题连接 题目大意给出一张无向图，图上每条边只允许经过一次，给出经过图的次数 ，找到经过的最长边中长度最小的长度。 建模很明显费用流建模，每条边权值为长度，流量为一，直接连边，注意建双向边。那这个最长的边的长度怎么着呢？其实很简单，只要将更新 的条件由 改为 即可。同理，最小费用也改为 （ 为汇点）。当增广到的流量大于 时，直接跳出搜索，输出答案即可。代码用的是 Dijkstra 找增广路，本来还在想势能怎么更新，写着写着发现没必要用势能，就直接放个阉割版 Dijkstra 上去了，好像也不用开 longlong。 代码 第一次写题解，如有什么错误或者不理解的地方，欢迎留言。"},{"title":"高等数学","date":"2023-05-23T09:57:31.835Z","url":"/2023/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/","categories":[["数学","/categories/%E6%95%B0%E5%AD%A6/"]],"content":"一个令人喜闻乐见的专题前言：关于我为什么要讲高数： 在一个月不黑风不高的晚上，某位神犇在为我们讲一道名为十二重计数法(神犇的blog)的神仙数学题时，出现了一个十分有趣的式子: \\begin{equation*} \\begin{split} \\ln_{}{(1-x^{t})} & = \\int \\frac{-tx^{t-1}}{1-x^{t}}dx\\\\ & = \\int (-t \\sum_{i=1}x^{ti-1})dx\\\\ & = -\\sum_{i=1}\\frac{x^{ti}}{i} \\end{split} \\end{equation*}但是由于大家的修行不够，并没有悟到该式子的真谛，所以今天有我来填这个大坑。（有些公式的证明可能没有办法全部展示完，对于重要的公式会单独写几篇博客 挖坑小能手）。 导数引入我们先回想一个初中就学过的函数 。那么，对于这个朴实无华的二次函数，我们该如何求出函数上每个点的切线斜率呢？在考虑这个问题之前，让我们先想一想如何求一次函数斜率。对于一次函数 ，k就是该函数的斜率。当然，也可以表示为 k=\\frac{\\Delta y}{\\Delta x}或者 k=\\frac{y_{2}-y_{1}}{x_{2}-x_{1}} \\quad (y_{1} < y_{2} \\enspace , \\enspace x_{1} < x_{2})那我们是不是也可以用同样的方式表示二次函数在某一点上的斜率呢？我们用 表示一段区间上的斜率，其中 ， ，为了方便理解，我们直接上图。 可以表示为： \\begin{equation*} \\begin{split} \\Delta y & =f(x_{2})-f(x_{1}) \\\\ & = f(x_{1}+\\Delta x) - f(x_{1}) \\end{split} \\end{equation*} 那么 可以表示为： k=\\frac{f(x+\\Delta x) - f(x)}{\\Delta x} 下一步我们让无线趋近于0，符号表示为，这样就可以表示图像在点的斜率。 k=\\lim_{\\Delta x\\to 0}\\frac{f(x+\\Delta x) - f(x)}{\\Delta x} 斜率其实就是导数的几何意义，下面给出导数的定义。 导数的定义定义设函数 在点的某个邻域内有定义，当自变量在处有增量 ， 也在该邻域内时，相应地函数取得增量；如果与之比当时极限存在，则称函数在点处可导，并称这个极限为函数在点处的导数，记作①；②；③，即 f'(x_{0})=\\lim_{\\Delta x \\to 0}\\frac{\\Delta y}{\\Delta x}=\\lim_{\\Delta x \\to 0}\\frac{f(x_{0}+\\Delta x)-f(x_{0})}{\\Delta x} 导函数几何意义公式常用函数导数 导数运算法则 复合函数求导设 且和都可导（忘写如何判断函数是否可导了，挖个坑），则复合函数的导数为 {\\large{\\frac{dy}{dx}=\\frac{dy}{du} \\cdot \\frac{du}{dx}}} \\quad 或 \\quad {\\large{y'(x)=f'(x) \\cdot g'(x)}}高阶导数高阶导数就是对函数进行大于等于二次求导，例如二阶导数可以表示为或 f^{(n)}(x)=(f^{(n-1)}(x))' "},{"title":"P2934题解","date":"2023-05-13T11:01:52.449Z","url":"/2023/05/13/P2934%E9%A2%98%E8%A7%A3/","categories":[["题解","/categories/%E9%A2%98%E8%A7%A3/"],["图论","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"P2934 [USACO09JAN]Safe Travel G 原题链接 读题 1.不成熟的想法想必大家看完题之后都跟我一样有一个共同的想法，那就是跑次短路，但是稍微思考一下就会发现其实不然，下面举个反例：我们看从1到6的最短路，应该是 1 -&gt; 4 -&gt; 6 ,如果跑次短路的话则会找到1 -&gt; 2 -&gt; 4 -&gt; 6。诶，这不对吧，题目要求我们不经过1节点到i节点的最后一条边，也就是删去最短路上i节点的父边，但是这里并没有删，因此 次短路X。 2.真正的解题思路 这里介绍一种算法，最短路树。 最短路树顾名思义就是在确定最短路径后将此路构建为一棵树。这棵树的性质就是每个父节点到儿子节点的距离为最短路（废话）。当原图的一条边不在树上时，我们将其称为非树边。根据最短路树的性质，在断开i节点到它父亲的边后，最短路一定会经过至少一条非树边，而且仅经过一条非树边，因为如果该路径经过多条非树边，那么总有一条非树边可以用最短路树上的一条不包含被断开边的链替代。所以，断开i节点的父边后，其最短路径一定是树边 -&gt; 非树边 -&gt; 树边 的形式。下面直接贺别人的例子方便大家理解 接着，我们想想如何找到这条非树边。稍微想一下我们就能发现，只有边的两个节点的LCA的后代为i且i为两个节点其中一个节点的祖先时，这条边才有可能是最好路径。继续贺别人的例子 最后，节点i的答案长度。因为不变，所以当最小时，答案最小。所以我们将按照的大小来排序，再枚举这条边能更新的点，那么每个点第一次被更新时的即为所求，每次更新完答案，我们就将这个点删去，以加快搜索进度。复杂度:。 Code "},{"title":"最小费用最大流","date":"2023-05-11T12:42:32.275Z","url":"/2023/05/11/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"费用流问题前言依旧是填坑，讲解最小费用最大流的解决方法，对最大流不熟悉的同学可以看我的前几篇文章。 费用流问题一个网络流的扩展问题，从名字中就能看出，就是在容量限制的基础上加上经过每条边需要花费的费用。最小费用最大流问题就是为了解决在给的流量F时最小的花费，未指定F时则求流量最大时的最小花费。各位神犇可以思考一下该以何种顺序搜索。 思想不难看出，有以下两种搜索顺序： 1.先找最大流，然后再不断缩小花费 2.先找最短路（最小花费），再在路径上不断增加流量。 很明显第二种搜索顺序更容易理解，代码也容易实现。下面详细说明该思想的实现方法。 实现方法 首先，我们要找最短路。让我们回忆一下最短路算法都有哪些，你应该马上能想到Floyd、Bellman—Ford、SPFA和Dijkstra算法。这些都可以用吗？想想处理残留网络的过程，会在流经的边上建立一条反向边，那么反向边的花费一定与其正向边相反，因此我们要处理负权变，那么似乎Dijkstra就不能用了。因此我们选择Bellman—Ford或SPFA算法（Floyd复杂度太高）。找到最短路径之后我们记录一下路径，以便之后最大流处理。 其次就是处理最大流了。最大流算法上就没什么限制，Edmonds-Karp、Dinic、ISAP、HLPP都可以，用自己拿手的（复杂度小的）写就行。 SPFA+Dinic: Code SPFA+EK Code 题外话大家都知道，Dijkstra无法处理负权变，这样无法保证其贪心的正确性。不过，我们可以引入“势能”的概念，动态的维护每个边的边长，来保证Dijkstra的正确性。感兴趣的话可以去看《挑战程序设计》或者自行搜索。这里不做过多介绍了，只给出代码供大家参考。 Code(P2153[SDOI2009]晨跑代码) "},{"title":"网络流拓展——HLPP算法","date":"2023-05-09T10:54:42.678Z","url":"/2023/05/09/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%8B%93%E5%B1%95%E2%80%94%E2%80%94HLPP%E7%AE%97%E6%B3%95/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"更高效的网络流算法前言填坑，介绍一种更高效的网络最大流算法HPLL（预留推进） HPLL算法在上一篇文章中，我们介绍了三种最大流算法：Edmonds-Karp、Dinic和ISAP，其中最优的复杂度为(ISAP)。但这样还不够，ISAP仍有改进的空间，于是乎出现了HPLL算法，其复杂度为。 思路和ISAP类似，我们可以从汇点T开始BFS，查找到每一个结点的高度，然后每次搜索只更新到高度为当前节点减一的位置。这里HPLL引入了一个“溢出”节点的概念，可以理解为每个节点都有一个容量无限大的“水库”。当一个节点向下推流时，可以将流量先放在该节点的“水库”里。以便之后的搜索。 具体步骤： 1.BFS，记录每个节点的高度（和ISAP类似） 2.从源点S开始搜索，将“水库”中流量不为0的节点放入优先队列。 3.以从高到低的顺序更新队列里的每个节点，并将更新到的溢出节点放入优先队列。 4.若该节点无法再找到合法的路径（路径容量已满或者所有邻居节点都高于该节点）且该节点还有溢出流量，则将该点提升至邻居节点中高度最小的节点的高度加一处。 5.若发现某一高度出现断层，则说明其节点以上所有节点都无法再更新（具体证明可以看《算法导论》）。 不断重复3、4，直到所有节点都无法找到合法路径为止。 Code 后记本篇文章比较简短，主要填上一篇文章的坑，若有任何错误或不清楚的地方，欢迎留言。 作者邮箱：2759094765@qq.com "},{"title":"网络流","date":"2023-05-05T10:18:59.630Z","url":"/2023/05/05/%E7%BD%91%E7%BB%9C%E6%B5%81/","categories":[["图论","/categories/%E5%9B%BE%E8%AE%BA/"],["网络流","/categories/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"content":"对网络流的初步认识写在前面这是本蒟蒻写的第一篇博客，请各位巨佬多多包涵，欢迎指出文章的错误。 什么是网络流？引入在最短路算法的学习中，我们将多个地点之间的道路转化成有向图（或无向图）来处理各个地点的最短路问题。网络流问题也类似，我们可以将生活中比较常见的物料流动系统，比如管道网络、信息网络、电网、物流网络等视为网络流。从生活中的例子里我们发现，网络流问题就是一类处理物料从源点以稳定速率生成，并通过有容量上限的各个物流通道，最后流向汇点的问题。下面给出网络流的具体定义。 定义网络流 G = ( V , E ) 是一个有向图，其中有N 个点、M 条边、源点S 、汇点T ，每条边 有一个非负的容量值 c ( u , v ) 0。 举个栗子：当然，除了表示容量值，我们还需要一个函数来定义当前流量，还有流之间的关系，接下来详细说一下流函数。流函数我们讲 定义为边的流量，并且满足一下性质： 1.容量限制：对于所有结点 u , v V ,要求 。 2.流量守恒：对于所有的节点 ，要求 。 3.斜对称：正向边的流量等于其对应反向边的流量经典问题——网络最大流既然已经明确了网络流的定义，那么不妨来看看这个最经典的网络流问题——网络最大流。通过上面的定义我们不难发现，在整个网络中存在多组流函数，其中使整个网络流量之和最大的流函数被称为最大流，此时的流量被称为最大流量。网络最大流问题既旨在寻找既定网络中的最大流量。为了处理最大流问题，我们伟大的先辈L.R.Ford和D.R.Fulkerson在1962年将原始-对偶算法应用于最大流问题，提出了Ford-Fulkerson方法（由于其方法有多种时间复杂度不同的算法实现，因此《算法导论》将其称为方法而不是算法，这里沿用此定义），下面引入相关概念。 Ford-Fulkerson方法简单来说，Ford-Fulkerson方法就是不断搜索可行的路径，并更新残余网络。 具体步骤： 1.一开始所有边的容量都为0。 2.根据网络流的三大性质，找到一条从s 到t的路径，并更新流量。 3.重复（2）操作，直到无法找到满足三大性质的路径。 那么，根据这三个步骤，我们的程序是不是已经呼之欲出了呢？ 诶，如果你只按这三个步骤搜索的话，或许已经发现这个程序会有一些错误，举个例子。很明显，我们已经没有办法找到其他符合要求的路径了，该网络流的最大流为1，但是我们得到的最大流并不是真正的答案，如果先走再走的话，该网络的最大流为2。究其原因，在的路径中边占据了之后的流量，我们可以认为这是一次 “错误” 的搜索，为了防止这种 “错误” 对以后产生影响，我们引入残留网络的概念。 残留网络：在每次搜索后，在经过的路径上反补一条与该路径方向相反的路径，形成的新图就叫残留网络。 这个过程可以理解为在每次搜索后建立一条用来 “反悔” 的路径，以保证之后的搜索不受 “错误” 查找的影响。Ford-Fulkerson方法就是基于残留网络和反补路径实现的。后文将详细讲述几个基于Ford-Fulkerson方法的算法 Edmonds-Karp算法EK算法是最典型的实现方式，按照Ford-Fulkerson的思路实现即可。为了防止在搜索时出现不断搜索一条路径的情况，我们用BFS实现。 Code 复杂度分析：EK查找增广路的总时间为 ,一次BFS时间为 ,所以总时间为 , Dinic算法在EK中，每次搜索都要重新找到一条由S到T的增广路，这样的复杂的显然是不可以接受的。在Dinic算法中，实现了一次对多条增广路的搜索。 Dinic思想： 1.BFS分层，记录每个节点最早被搜索到的深度。 2.DFS在分层图上搜索，每次只能搜索到下一个深度的邻居结点，找到一条从当前结点v到汇点T的路径，并在回溯时更新流量。 Code 趣味小知识 算法来源于苏联学者Yefim Dinitz1970年发表的论文，但是这篇文章由于收到刊物篇幅限制写的过于简短，晦涩难懂，后来被两位美国学者解释、实现并大力推荐，但是误把Dinitz拼成Dinic。Dinitz在2006年写了一篇文章来解释这个算法的来龙去脉。虽然Dinic算法看起来像是对EK算法的改进，但其实EK算法的出现要比Dinic算法晚两年（1972）。 ISAP算法ISAP算法是对Dinic算法的进一步改进，在Dinic中，我们进行了多次BFS分层，而ISAP只需要一次BFS分层，然后再分层图上多次寻找增广路，为了更新残留网络，ISAP直接在原分层图上修改，而不是像Dinic一样进行多次BFS，因此有更优秀的复杂度。 ISAP思想： 1.从汇点T开始BFS，记录每个节点到T的距离，可以理解为高度。 2.从源点S开始DFS，在寻找路径时，按从高到低的顺序递减搜索，在s的邻居节点中，从高度比s小的节点开始搜索，每次搜索高度减1，到达汇点T后回溯，更新残留网络。 3.回到s,若无法找到高度低于s的节点，则将s的高度提升到最低的邻居节点的高度加1的高度，若某一高度出现断层（即该高度没有节点），则说明没有新的增广路，退出搜索。 Code 挖坑 [x] 预留推进 [x] 费用流 [ ] 二分图匹配，最小割 完结散花由于本人是第一次写博客，如果有任何问题（排版，思路，代码等），欢迎留言。 作者邮箱：2759094765@qq.com "}]